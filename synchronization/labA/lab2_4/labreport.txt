2.4. Сделайте “грубую” реализацию спинлока и мутекса при помощи cas-функции и
    futex. Используйте их для синхронизации доступа к разделяемому ресурсу. Объясните
    принцип их работы.

    ? mutex vs spinlock
    -   mutex 
            когда поток пытается захватить заблокированный мьютекс:
                он блокируется и переводится в состояние ожидания (sleep)
                управление передается ядру ОС -> не тратит CPU
            когда мьютекс освобождается (какой-то второй поток который держал мьютекс его разблокирует):
                ОС пробуждает наш ожидающий поток (wake up)
                при получении кванта времени поток продолжит выполнение
            ! использует сискол futex -> требуется переключение контекста. (НО не потребляет CPU пока спит)

        spinlock
            когда поток пытается захватить заблокированный спинлок:
                поток продолжает в цикле проверять состояние лока и пытается заблокировать (значит другой поток не может занять его место)
                не освобождает CPU
            ! работает полностью в user space -> не требует переключения контекста
            ! 100% загрузка ядра CPU из-за цикла ожидания блокировки

        обобщение:
            при заблокированном мьютексе поток переводится в сон; при заблокированном локе поток постоянно пытается заблокировать.
            мьютекс использует сисколы, спинлок - нет. 
            при спящем мьютексе ОС передает ядро активному потоку, при спинлоке долбящийся поток продолжит занимать ядро.

        ответ: https://stackoverflow.com/questions/5869825/when-should-one-use-a-spinlock-instead-of-mutex

    1) кастомный спинлок
        в терминале пишу:
            cd custom_spinlock
            gcc main.c queue_custom.c myspinlock.c -o res && ./res
        сравнение производительности с posix примитивами:
            спинлок:
                cd custom_spinlock
                gcc main.c queue_custom.c myspinlock.c -o res && ./res
                gcc main_pthread.c queue_pthread.c -o res && ./res

                вывод кастомного спинлока:
                    TOTAL: swap=0 asc=0 dsc=0 eq=0
                    TOTAL: swap=1406186 asc=281932 dsc=281300 eq=2250746
                    TOTAL: swap=2861561 asc=572915 dsc=572231 eq=4581687
                    TOTAL: swap=4331152 asc=866190 dsc=867007 eq=6934132
                    TOTAL: swap=5797578 asc=1158823 dsc=1160573 eq=9281710
                    TOTAL: swap=7260474 asc=1451726 dsc=1453264 eq=11621306
                    TOTAL: swap=8726930 asc=1745691 dsc=1746560 eq=13969550
                    TOTAL: swap=10181867 asc=2036620 dsc=2038132 eq=16298421
                    TOTAL: swap=11609497 asc=2322828 dsc=2324049 eq=18587119
                    TOTAL: swap=13054334 asc=2612375 dsc=2611690 eq=20896807
                    TOTAL: swap=14496791 asc=2900234 dsc=2899988 eq=23201623
                вывод posix спинлока:
                    TOTAL: swap=0 asc=0 dsc=0 eq=0
                    TOTAL: swap=2485564 asc=487314 dsc=626694 eq=3876864
                    TOTAL: swap=6174336 asc=1246678 dsc=1246466 eq=9918766
                    TOTAL: swap=9252399 asc=1868200 dsc=1866745 eq=14867984
                    TOTAL: swap=12371334 asc=2497353 dsc=2496943 eq=19892949
                    TOTAL: swap=13948899 asc=2780333 dsc=3128086 eq=22159874
                    TOTAL: swap=16783874 asc=3346904 dsc=3762818 eq=26676837
                    TOTAL: swap=21855712 asc=4411753 dsc=4409693 eq=35168233
                    TOTAL: swap=24951764 asc=5039101 dsc=5033029 eq=40159374
                    TOTAL: swap=30881616 asc=6299965 dsc=5662991 eq=50206431
                    TOTAL: swap=31329805 asc=6326681 dsc=6319573 eq=50426202

                кастомный спинлок: (14496791 + 2900234 + 2899988 + 23201623) / 10 = 4.35 млн/сек
                posix спинлок: (31329805 + 6326681 + 6319573 + 50426202) / 10 = 9.44 млн/сек 

                ? почему posix спинлок быстрее
                - 

            мьютекс: 
                cd custom_spinlock
                gcc main.c queue_custom.c mymutex.c -o res && ./res
                gcc main_pthread.c queue_pthread.c -o res && ./res

                вывод кастомного мьютекса:
                    TOTAL: swap=0 asc=0 dsc=0 eq=0
                    TOTAL: swap=605127 asc=117480 dsc=105529 eq=946027
                    TOTAL: swap=1231936 asc=239549 dsc=215373 eq=1920543
                    TOTAL: swap=1693705 asc=327241 dsc=326718 eq=2616213
                    TOTAL: swap=2019613 asc=385451 dsc=432278 eq=3076050
                    TOTAL: swap=2230947 asc=478382 dsc=0 eq=3826199
                    TOTAL: swap=2021707 asc=434951 dsc=0 eq=3465251
                    TOTAL: swap=3949317 asc=765199 dsc=761762 eq=6084695
                    TOTAL: swap=4515260 asc=872353 dsc=870936 eq=6952880
                    TOTAL: swap=5075647 asc=871234 dsc=1957786 eq=6942036
                    TOTAL: swap=5636745 asc=1088154 dsc=1087050 eq=8671489
                вывод posix мьютекса:
                    TOTAL: swap=0 asc=0 dsc=0 eq=0
                    TOTAL: swap=1904301 asc=227581 dsc=244734 eq=2029221
                    TOTAL: swap=4135698 asc=477492 dsc=518911 eq=5143773
                    TOTAL: swap=5650337 asc=616123 dsc=842084 eq=6881700
                    TOTAL: swap=7818755 asc=821415 dsc=1077994 eq=8621980
                    TOTAL: swap=9960017 asc=1101621 dsc=1327102 eq=10081673
                    TOTAL: swap=11879272 asc=1355421 dsc=1605569 eq=11887425
                    TOTAL: swap=13945794 asc=1613022 dsc=1871915 eq=13865407
                    TOTAL: swap=15878982 asc=1920953 dsc=2098454 eq=15812835
                    TOTAL: swap=17889657 asc=2230385 dsc=2308537 eq=17846414
                    TOTAL: swap=24093887 asc=2776269 dsc=5075247 eq=21908102
                    TOTAL: swap=22103301 asc=2724239 dsc=2771038 eq=21627205
                
                кастомный мьютекс: (5636745 + 1088154 + 1087050 + 8671489) / 10 = 16.5 млн/сек
                posix мьютекс: (22103301 + 2724239 + 2771038 + 21627205) / 10 = 53.85 млн/сек

                ? почему posix мьютекс быстрее
                - custom_mutex_lock() использует atomic_compare_exchange_strong в цикле, пока не получит блокировку -> 
                    активное ожидание (busy-waiting). Поток постоянно использует cpu time, даже когда мьютекс занят -> 
                    создает нагрузку и мешает работать другим потокам, включая тот, который должен освободить блокировку.

            ? почему posix мьютекс быстрее posix спинлока 
            -   
                спинлок (активное ожидание): поток, не сумевший захватить спинлок, выполняет цикл с (CAS - compare and swap) по адресу переменной блокировки. 
                    Вижу два негативных эффекта:
                        - интенсивный трафик шины: каждая атомарная операция требует обеспечения когерентности кэшей всех ядер процессора.
                        - инвалидация кэш-линии: постоянные попытки записи CAS-ом вызывают инвалидацию кэш-линии (помечание как устаревшей) 
                            на всех остальных ядрах. Последующие попытки других потоков прочитать эту переменную будут приводить к cache miss-ам 
                            и принудительной пересылке обновленной линии по шине.
                мьютекс (пассивное ожидание): поток, не сумевший захватить мьютекс, после небольшого числа попыток переходит в состояние блокировки (sleep) 
                    через сискол futex.
                        - освобождение cpu time: ядро снимает поток с выполнения, и процессор может работать над другими задачами.
                        - снятие нагрузки с кэша: когерентность поддерживается только в ключевые моменты (захват и освобождение) -> снижается трафик шины 
                            и количество cache miss-ов.
                
                -> постоянные CAS операции спинлока заставляют ядра CPU "перекидываться" владением участком памяти с блокировкой, что затратно. 
                    Мьютекс минимизирует эти дорогие взаимодействия, переводя ждущие потоки в сон.

                когерентность кэшей - свойство многоядерной системы - все ядра процессора видят одинаковое/согласованное значение одной и той же ячейки памяти. 
        
    
        ? есть ли race condition в текущей реализации myspinlock.c
        - Да. В custom_spinlock_lock():
            Между успешным CAS и установкой owner/cnt другой поток может:
                Увидеть lock == 1, но owner еще не установлен
                Попытаться проверить owner в custom_spinlock_unlock() и получить мусорное значение
            Сценарий в custom_spinlock_unlock():
                Два потока одновременно проверяют владельца:
                    A: читает s->owner (видит устаревшее значение)
                    скедулер передает управление потоку B
                    B: захватывает спинлок, устанавливает s->owner = new_tid, освобождает спинлок
                    скедулер передает управление потоку A
                    A: видит старое значение s->owner, делает неправильный вывод -> s->cnt = 0 - 1 = -1 -> спинлок не будет освобожден так как не выполнено условие:
                        if (s->cnt == 0) {
                            s->owner = 0;
                            // сбрасываю лок атомарно
                            atomic_store(&s->lock, 0);
                        }
                -> проверка if (s->owner == gettid()) может пройти для двух разных потоков одновременно, если между чтением и действием произойдет context switch


        
        реализация взята из lab2_2, lab2_3. Показывать надо myspinlock.c.

        atomic_int
            тип данных, который, в отличие от простого int, гарантирует атомарность всех операций с ним.

        ? почему используем atomic_int а не int?
        - чтобы не было гонок между потоками при проверке и установке флага lock. Если бы взяли int, то например два потока 
            могли бы прочитать лок как 1 и оба записать 0, посчитав, что они захватили лок. Но 2 потока не могут захватывать лок одновременно.
        
        atomic_init
            void atomic_init(volatile atomic_int *object, atomic_int desired)
                object - указатель на переменную типа atomic_int, которую нужно инициализировать.
                desired - значение, с которым должна быть инициализирована эта переменная.

            используется для инициализации атомарного объекта. Устанавливает начальное значение атомарной переменной.

            в моем случае: 
                atomic_init(&s->lock, 1);

        atomic_compare_exchange_strong
            bool atomic_compare_exchange_strong(volatile atomic_int *object, atomic_int *expected, atomic_int desired)
                object - указатель на переменную типа atomic_int, которую нужно изменить.
                expected - указатель на переменную типа atomic_int, содержащую ожидаемое значение.
                desired - новое значение, которое нужно установить.

            сравнивает текущее значение атомарной переменной object со значением, указанным в expected. Если они равны, то устанавливает 
                значение desired в object и возвращает trut. В противном случае, оставляет object без изменений и возвращает false.

            в моем случае:
                if (atomic_compare_exchange_strong(&s->lock, &one, 0)) {
                    break;
                }
            
            https://spec-zone.ru/cpp/atomic/atomic_compare_exchange

    2) кастомный мутекс
        в терминале пишу:
            cd custom_mutex
            gcc main.c queue.c mymutex.c -o res && ./res

        futex - fast userspace mutex - механизм синхронизации, позволяет случае работать без перехода в ядро 
            (через атомарные CAS‑операции в userspace) и только при конкуренции использовать один сискол для сна/пробуждения.
            int futex(int *uaddr, int op, int val, const struct timespec *timeout, int *uaddr2, int val3);
                uaddr - адрес в userspace переменной, с которой работают потоки
                op - операция: FUTEX_WAIT, FUTEX_WAKE
                    FUTEX_WAIT - ждет, пока значение uaddr станет равным val
                    FUTEX_WAKE - пробуждает, если значение uaddr меньше val (val - максимальное количество потоков для пробуждения)
                val - значение, которое должно быть установлено в uaddr
                timeout - время ожидания, если op = FUTEX_WAIT
                uaddr2 - не используется
                val3 - не используется

        я взял большую часть кода из lab2_3. Из нового только mymutex.c:
            int futex_wait(atomic_int *uaddr, int val) 
                если по адресу uaddr лежит val, засунь меня в список спящих потоков; разбуди меня, 
                    когда кто‑то вызовет FUTEX_WAKE():
                return syscall(SYS_futex, uaddr, FUTEX_WAIT, val, NULL, NULL, 0);

            int futex_wake(atomic_int *uaddr, int n)
                разбуди до n спящих потоков, которые ждут на этом адресе uaddr:
                return syscall(SYS_futex, uaddr, FUTEX_WAKE, n, NULL, NULL, 0);

            void custom_mutex_init(custom_spinlock_t *s)

            void custom_mutex_lock(custom_spinlock_t *s)
                если поток не может захватить мьютекс (он уже 1 <-> захвачен), то делаю futex_wait() <-> засыпаю, пока 
                    значение в *uaddr не станет другим благодаря другим потокам.

            void custom_spinlock_unlock(custom_spinlock_t *s) 
                потоки ожидающие на s->lock выполняют futex_wait() и когда мьютекс освобождается, futex_wake() сообщает ОС, что есть поток, 
                    который может продолжить выполнение.
                atomic_store() - снимает мьютекс (s->lock = 0)
                futex_wake() - пробуждает один поток который ожидает на s->lock
            
            пример: поток a захватил мьютекс и работает, 
                    поток b пытается захватить тот же мьютекс и засыпает ожидая с помощью futex_wait(),
                    когда a доработал, вызовется custom_mutex_unlock() и в нем atomic_store() для освобождения мьютекса,
                    затем futex_wake() пробудить один из потоков (b) которые были заблокированы,
                    так как теперь мьютекс освободился, b его захватывает и работает сам. 

? доп: race condition в custom_spinlock_unlock()
    - да. есть так как операции проверки owner-а и инкремент/декремент счетчика неатомарные
    решения (1 из 2): 
        1 - сделать операции атомарными. Для этого owner и cnt должны стать таковыми
        2 - убрать реентабельность в myspinlock.c

? есть ли race condition, пояснить почему