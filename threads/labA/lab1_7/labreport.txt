1.7. Разработать собственную функцию для создания пользовательских потоков:
    int uthread_create(uthread_t thread, void *(start_routine), void *arg);
    Функция должна возвращать успех-неуспех.
    Допускается реализация без вытеснения потока.



    в терминале выполняю: 
        gcc -shared -o libuthread.so uthread.c
        gcc -o test test.c -L. -luthread
        export LD_LIBRARY_PATH="$PWD:$LD_LIBRARY_PATH"
        ./test
    вывод: 
        [thread 1] - iteration: 0
        [thread 2] - iteration: 0
        [thread 1] - iteration: 1
        [thread 2] - iteration: 1
        [thread 1] - iteration: 2
        [thread 2] - iteration: 2
        [thread 1] - iteration: 3
        [thread 2] - iteration: 3
        [thread 1] - iteration: 4
        [thread 2] - iteration: 4
        [uthread_wrapper] поток 0 завершил работу.
        [uthread_wrapper] поток 1 завершил работу.

    описание логики:
        uthread.c
            разберем все глобальные статик переменные:
                static ucontext_t ucontexts[UTHREAD_MAX];
                    массив контекстов юзер потоков
                static char ustacks[UTHREAD_MAX][UTHREAD_STACK_SIZE];
                    массив выделенных для каждого потока "стеков". Заранее резервируюм UTHREAD_MAX 
                    стеков - по одному на каждый поток, каждый размером UTHREAD_STACK_SIZE
                static void *(*ufuncs[UTHREAD_MAX])(void *);
                    массив указателей на сами юзер функции start_routine()
                static void *uargs[UTHREAD_MAX];
                    массив указателей на аргументы, которые юзер передавал в uthread_create()

                static int ucount = 0;
                    счетчик созданных юзер потоков. При каждом успешном вызове uthread_create() 
                    инкременируется.
                static int current = -1;
                    индекс текущего <=> выполняющегося потока. 
                    ! Изначально -1, чтобы uthread_yield() знал, что это - первый запуск и должен 
                    ввызвать setcontext() без предварительного swapcontext().

            uthread_create(uthread_t *thread, void *(*start_routine)(void *), void *arg)
                если создано юзер потоков больше чем UTHREAD_MAX, то возвращаю -1:
                    if (ucount >= UTHREAD_MAX) {
                        return -1;
                    }
                текущий счетчик созданных потоков - ucount становится id нового юзер потока. 
                    getcontext() заполняет структуру ucontexts[id] контекстом текущего юзер потока: 
                    регистры, маски сигналов, ...: 
                    int id = ucount++;
                    if (getcontext(&ucontexts[id]) == -1) {
                        return -1;
                    }
                модифицирую этот контекст дабы превратить в стартовую точку нового юзер потока:
                    uc_link - указывает куда вернуться после завершения контекста. NULL значит 
                    никуда не возвращаться;
                    uc_stack.ss_sp - адрес начала (нижняя вершина) стека, который заранее 
                    выделен в статическом массиве ustacks[id];
                    uc_stack.ss_size - размер стека.
                    ucontexts[id].uc_link = NULL;
                    ucontexts[id].uc_stack.ss_sp = ustacks[id];
                    ucontexts[id].uc_stack.ss_size = UTHREAD_STACK_SIZE;
                юзер функцию и её аргумент сохраняю в массивах ufuncs и uargs, чтобы в момент запуска потока 
                    в uthread_wrapper() знать, что именно вызывать:
                    ufuncs[id] = start_routine;
                    uargs[id] = arg;
                модифицирую ucontexts[id] так, что при первом setcontext() или swapcontext() управление начнёт 
                    выполняться не с текущего места, а с функции uthread_wrapper():
                    makecontext(&ucontexts[id], uthread_wrapper, 0);
                дескриптор потока - взятый из ucount id:
                    *thread = id;

                ? getcontext() сохраняет в ucontexts[id] контекст текущего потока. Зачем что-то править?
                - хочу чтобы при первом setcontext() или swapcontext() управление НЕ ВОЗВРАЩАЛОСЬ в uthread_create(), 
                    а прыгнуло в начало нового потока, со своим стеком и с вызовом именно нашей обёртки uthread_wrapper().
                    Установление новой точки входа происходит именно через makecontext() - изменяю ip регистр, чтобы при 
                    переключении контекстов управление возвращалось в uthread_wrapper().

            static void uthread_wrapper(void) 
                точка входа в каждый юзер поток после переключения контекста. 

                беру глобальную переменную current - индекс текущего юзер потока:
                    int id = current;
                беру из массива ufuncs указатель на start_routine, и вызываю его, передавая аргумент uargs[id]. 
                    Возвращённое значение сохраняю в локальной переменной ret:
                    void *ret = ufuncs[id](uargs[id]);
                Как только start_routine вернула управление, делаю uthread_yield(), чтобы передать управление 
                    следующему потоку. Если бы этой строки не было, то застрял бы в одном потоке:
                    uthread_yield();
                Если после uthread_yield() снова вернулись именно в эту функцию (ucount == 1 или все другие потоки 
                    завершились), значит все потоки отработали и uthread_yield() больше не может передать управление 
                    другим потокам. Значит убиваем процесс целиком:
                    exit(0);
            
            void uthread_yield(void) 
                функция передачи управления от текущего потока к следующему.

                проверяю создавали ли мы вообще юзер потоки:
                    if (ucount == 0) {
                        return;
                    }
                сохраняю старый индекс в prev, инкременирую current по модулю общего числа потоков ucount:
                    int prev = current;
                    current = (current + 1) % ucount;
                далее раньше было так. И это вполне логично ибо при первом вызове юзер потока, когда ещё ни разу не 
                    было выполнено переключение, еще ни один контекст впринципе не сохранен. Вызываю setcontext() 
                    для исполнения контекста потока с номером current. Сохранения контекста не происходит.
                    В другом случае сначала сохраняю контекст текущего "старого" потока, а затем восстанавливаю 
                    контекст "нового" потока ucontexts[current]. Т.е. переключил исполнение из одного потока в другой: 
                    if (prev == -1) {
                        setcontext(&ucontexts[current]);
                    } else {
                        swapcontext(&ucontexts[prev], &ucontexts[current]);
                    }
                НО сейчас оставил только swapcontext(&ucontexts[prev], &ucontexts[current]) так как prev никогда не равен -1.

            void uthread_run(void)
                запусскаею первый юзер поток. 
                    current = 0;
                восстанавливаю сохранённый контекст потока current: загружаю его регистры(sp, ip - указывает на 
                    uthread_wrapper()):
                    setcontext(&ucontexts[current]);
                ! После этого main уже не продолжит исполнение (ее контекст не был сохранён), и юзер потоки начнут 
                    работать по кругу, вызывая uthread_yield().



            4 функции ниже позволяют переключать на уровне юзера контекст между различными потоками в рамках одного процесса:
                setcontext()
                    int setcontext(const ucontext_t *ucp); 
                        ucp - указатель на структуру контекста ucontext_t, который будет восстанавливаться

                    Функция setcontext() восстанавливает пользовательский контекст, на который указывает ucp (и 
                    переносит туда выполнение). 
                    Успешный вызов не возвращает ничего. Контекст должен быть получен с помощью вызова 
                    getcontext() или makecontext(), или передан как третий аргумент обработчика сигнала.

                    ? что подразумевается под восстановлением контекста?
                    - восстановка регистров(sp, ip, ...), масок сигналов, стека на тот который указан в ucp->uc_stack,
                        перенос выполнения в то место, где при getcontext() или makecontext() был сохранён контекст.
                        ! Это goto() на зафиксированный в структуре контекст. 
                        ! Если для данного контекста в uc_link указан другой контекст, то после завершения этого 
                            один раз выполнится setcontext для uc_link.

                    https://www.opennet.ru/man.shtml?topic=getcontext&category=2&russian=0
                
                getcontext()
                    int getcontext(ucontext_t *ucp);
                        ucp - указатель на структуру контекста, в которую сохранится контекст текущего юзер потока. 
                        Пример этой структуры контекста ucontext:
                        typedef struct ucontext {
                            struct ucontext *uc_link;       points to the context that will be resumed when the current context terminates
                            sigset_t uc_sigmask;            set of signals blocked in this context
                            stack_t uc_stack;               stack used by current context
                            mcontext_t uc_mcontext;         machine-specific representation of the saved context, that includes the calling 
                                                                thread's machine registers.
                            ...
                        } ucontext_t;

                    Функция getcontext() инициализирует структуру ucontext_t в которую сохранится текущий активный контекст.

                    в моем случае:
                        getcontext(&ucontexts[id])

                    https://www.opennet.ru/man.shtml?topic=getcontext&category=2&russian=0
                    https://man7.org/linux/man-pages/man2/setcontext.2.html

                makecontext()
                    void makecontext(ucontext_t *ucp, void *func(), int argc, ...);
                        ucp - указатель на структуру контекста, которая будет модифицириована
                        func() - указатель на функцию, которая будет исполняться в контексте
                        argc - количество параметров у функции func()

                    Функция makecontext() изменяет контекст, на который указывает ucp (полученный с помощью вызова getcontext()). 
                        ! Перед вызовом makecontext() необходимо выделить для этого контекста новый стек, указав его в ucp->uc_stack, 
                            и определить контекст наследника, указав его в ucp->uc_link (предложение взято из мэйна). 
                        В дальнейшем, когда этот контекст активируется (с помощью setcontext() или swapcontext()), то сперва вызвается 
                            функция func() с аргументами, указанными за argc, а после возврата из func(), активируется 
                            контекст наследника (при условии что он не NULL, тогда просто возвращается).

                    в моем случае:
                        ucontexts[id].uc_link = NULL; 
                        ucontexts[id].uc_stack.ss_sp = ustacks[id]; 
                        ucontexts[id].uc_stack.ss_size = UTHREAD_STACK_SIZE;
                        ...
                        makecontext(&ucontexts[id], uthread_wrapper, 0);
                    
                    https://www.opennet.ru/man.shtml?topic=makecontext&category=3&russian=0
                    https://pubs.opengroup.org/onlinepubs/009695399/functions/makecontext.html

                swapcontext()
                    int swapcontext (ucontext_t *oucp, ucontext_t *ucp); 
                        oucp - указатель на структуру контекста, в которую сохраняется контекст текущего потока
                        ucp - указатель на структуру контекста, которая будет восстанавливаться

                    Функция swapcontext() сохраняет текущий контекст в структуру, на которую указывает oucp, 
                        а затем активирует контекст, на который указывает ucp.
                    То есть фактически swapcontext() - это комбинация setcontext() и getcontext():
                        if (getcontext(oucp) == 0) {
                            setcontext(ucp);
                        }

                    в моем случае: 
                        swapcontext(&ucontexts[prev], &ucontexts[current]);

                    https://www.opennet.ru/man.shtml?topic=makecontext&category=3&russian=0